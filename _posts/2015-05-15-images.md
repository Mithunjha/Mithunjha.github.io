# Needleman-Wunsch algorithm for DNA sequence alignment

Hi everyone!

DNA, or deoxyribonucleic acid, is a double helix molecule made out of four nucleotide bases, namely Adenine (A), Guanine (G), Thymine (T) and Cytosine (C), that always pair together in same way, A with T; C with G. ‚ÄòGenome‚Äô is a complete set of DNA of an organism, which contains instructions that allow an organism to develop and grow. The human genome is 3.2 billion bases long.

![image source:¬†[https://www.yourgenome.org/facts/what-is-dna](https://www.yourgenome.org/facts/what-is-dna)](https://miro.medium.com/max/875/1*ERHPCWvA_6de9cpMomEhhg.jpeg)

image source:¬†[https://www.yourgenome.org/facts/what-is-dna](https://www.yourgenome.org/facts/what-is-dna)

Have you ever wondered how much similar your DNA is to your parent‚Äôs DNA or to someone else‚Äôs DNA?

This article is about implementing Needleman-Wunsch algorithm for DNA sequence alignment. You‚Äôll learn to interpret the similarity between two sequences using a score! Let‚Äôs dive into the topic!

# ****What is Sequence Alignment?****

Sequence alignment is a method of comparing sequences like DNA or protein in order to find similarities between two or more sequences. This will provide you with an answer to the question: whether two sequences have evolved from a common ancestor or not. It is useful in determining evolutionary relationships between different species. There are two types of pairwise alignment methods,

1. Global alignment ‚Äî This is suitable to compare two sequences across their entire length. Needleman-Wunsch algorithm (1970) is used for optimal global alignment.

2. Local alignment ‚Äî This is suitable to identify local similarities between two sequences , useful when sequences are very distant and when one sequence is significantly shorter than the other. Smith-Waterman algorithm (1980) is used for optimal local alignment.

Additionally, more than two sequences can be aligned using multiple sequence alignment methods. In this post, we are going to look at the alignment between two sequences.

# ****Global alignment****

Consider the two sequences: X= ATGCTAGT and Y= ATGTTAT

![https://miro.medium.com/max/875/1*z_61HNBz1linOq4V0PqJAA.png](https://miro.medium.com/max/875/1*z_61HNBz1linOq4V0PqJAA.png)

Two sequences can be aligned in numerous ways. But during sequence alignment we seek for the one that captures genuine similarities. The degree of similarity or differences between two sequences has to be measured. How to determine the sequence which has maximum matches? What is the measure of similarity between two sequences?

We can come up with a measure by defining a scoring scheme/function. A simple scoring scheme is to use +1 score for matches, -1 for mismatches and 0 for gaps. Different scoring schemes are used in real world sequence alignment problems. The substitution matrix/similarity matrix for a simple scoring function will look like this:

```
+---------------------------+
|       A     T    G     C  |
+---------------------------+
| A     1    -1    -1    -1 |
| T    -1     1    -1    -1 |
| G    -1    -1     1    -1 |
| C    -1    -1    -1     1 |
+---------------------------+
```

Consider these alignments!

![https://miro.medium.com/max/875/1*N8-p14EoYsIEscsB9OU0aA.png](https://miro.medium.com/max/875/1*N8-p14EoYsIEscsB9OU0aA.png)

By comparing these alignment scores, we can determine the best sequence alignment to be the one with the maximum score.

A gap in an alignment is introduced by deletion or insertion of a base. Note that in previous examples we didn‚Äôt consider the gap penalties. But in real scenario, the penalty for gap should be higher than mismatch score. Because a gap shifts the reading frame. There are several gap penalty functions such as constant gap penalty, linear gap penalty, affine gap penalty etc.

Alignment score tells us which alignment is the best alignment; In other words, which alignment has the highest alignment score, but it doesn‚Äôt tell us how to find the best alignment. Obviously, we can generate all possible alignments and calculate their score individually. But! Do you know the number of unique global alignments possible for two N length sequences? It can be determined by the equation given below,

![https://miro.medium.com/max/146/1*bJK0Y6AZX5m5FGXX_3693w.png](https://miro.medium.com/max/146/1*bJK0Y6AZX5m5FGXX_3693w.png)

If we have two sequences with 12 residues, then we should consider around 1 million possible unique alignments and calculate their alignment scores individually to determine the best alignment. Still do you think it‚Äôs possible to find every alignment, calculate its scores and then determine the best alignment? I would say No!

This is where dynamic programming comes into play!

Dynamic programming was invented by Richard Bellman in 1953. If a problem can be solved by breaking it into simpler sub problems, then dynamic programming methods are applicable to solve them. Overlapping subproblems and optimal substructure are the two attributes a problem should have in order to apply Dynamic programming methods. This is widely used in the field of bioinformatics and computational biology. Needleman-Wunsch algorithm is an application of dynamic programming. This was invented by Saul Needleman and Christian Wunsch in 1970. Basically, Alignment of two long sequence is done using optimal alignment of their prefixes.

Let‚Äôs start coding,

```python
**import pandas as pd 

#define your substituion matrix
score=[['','A','C','T','G'],['A','1','-1','-1','-1'],['C','-1','1','-1','-1'],['T','-1','-1','1','-1'],['G','-1','-1','-1','1']]

#convert to dataframe
score=pd.DataFrame(score)
new_header = score.iloc[0] 
score = score[1:] 
score.columns = new_header
score=score.set_index([''])

score #simple substitution matrix for DNA alignment

import numpy as np
def lcs(X,Y,score,gap): #(X=sequence_1,Y=sequence_2,score=similarity matrix,gap=penalty)
    n = len(X) #no of column
    m = len(Y) #no of rows
    B = np.zeros((m+1,n+1), dtype=str) #traceback matrix
    C = np.zeros((m+1,n+1), dtype=int)  #score matrix
    
    #Initialization
    for i in range(0,m+1): 
        C[i][0]=gap*i   #linear gap penalty 
        B[i][0]='u' #'up'
    for j in range(0,n+1):
        C[0][j]=gap*j
        B[0][j]='l' #'left'
    B[0][0]= '*' #'done'
    
    #calculate score for each residue and fill matrices
    for i in range(1,m+1):
        for j in range(1,n+1):
            match = C[i - 1][j - 1] + int(score.loc[X[j-1],Y[i-1]])
            delete = C[i - 1][j] +gap
            insert = C[i][j - 1] +gap
            C[i][j] = max(match, delete, insert) #get maximum value
            if C[i][j]==match:
                B[i][j]='d' #'diag'
            elif C[i][j]==delete:
                B[i][j]='u'
            else:
                B[i][j]='l'
    return C,B

#traceback using recursion
def print_LCS(B,X,Y,i,j): #B=direction matrix,X=sequence_1,Y=sequence_2
    if B[i,j]=='*':
        return 
    if B[i,j]=='d':
        print_LCS(B,X,Y,i-1,j-1)
        print (X[j-1],Y[i-1])
    elif B[i,j]=='u':
        print_LCS(B,X,Y,i-1,j)
        print ('-',Y[i-1])
    elif B[i,j]=='l':
        print_LCS(B,X,Y,i,j-1)
        print (X[j-1],'-')**
```

The Needleman-Wunsch algorithm requires two matrices: score matrix and traceback matrix. The algorithm consists of following steps:

****1. Initialization of matrices****
This is how both matrices look like after initialization, where the linear gap penalty = -1 is used.

![https://miro.medium.com/max/840/1*La-5Xu8NPsjc1hYgyCROZw.png](https://miro.medium.com/max/840/1*La-5Xu8NPsjc1hYgyCROZw.png)

****2. Calculate scores to fill score matrix and traceback matrix.****

![https://miro.medium.com/max/875/1*5OsQ4owLL9uJJSl-28OvkQ.png](https://miro.medium.com/max/875/1*5OsQ4owLL9uJJSl-28OvkQ.png)

****3. Deduce the best alignment from traceback matrix****
Traceback begins with the bottom right-most cell (last cell to be filled). Move according to the value in the cell until ‚Äòdone‚Äô cell is reached.

![https://miro.medium.com/max/568/1*EL9p3RXZCMCEkwFoOWjH6w.png](https://miro.medium.com/max/568/1*EL9p3RXZCMCEkwFoOWjH6w.png)

****How to interpret the best alignment from above matrix?****
The cell value ‚Äòdiag‚Äô interprets that residues from two sequences are aligned, ‚Äòup‚Äô can be interpreted as a gap added in top sequence or insertion. Similarly, ‚Äòleft‚Äô can be interpreted as a gap added in left sequence or deletion.

![https://miro.medium.com/max/875/1*z3LDU4Q-KytmbYzSkPNQew.png](https://miro.medium.com/max/875/1*z3LDU4Q-KytmbYzSkPNQew.png)

This is the optimal alignment derived using Needleman-Wunsch algorithm.

Protein sequence alignment is more preferred than DNA sequence alignment. Because DNA sequences are made of only 4 bases (A, G, C, T), while protein sequences are made of 20 amino acid residues. It is less likely to get a match by chance in protein sequence alignment.

Protein sequence alignments doesn‚Äôt vary much from DNA sequence alignment. Unlike DNA, proteins have 20 bases. The only difference between DNA alignment and protein alignment is the substitution matrix. Having weighted scores is important in protein sequence alignment. There are two widely used families of substitution matrices for protein alignment. Those are,
1.¬†[PAM](http://prowl.rockefeller.edu/aainfo/pam250.htm)
2.¬†[BLOSUM](https://www.ncbi.nlm.nih.gov/Class/FieldGuide/BLOSUM62.txt)

Finally, Studying the DNA is an important aspect in biology. DNA sequence analysis has become a major research topic nowadays and is applied in many fields such as Forensic Biology, Biotechnology, Virology and so on. This article would‚Äôve given you the general idea about comparing two whole sequences.

Hope you enjoyed reading this article and learned something!!

Thanks for reading üòäüëç

[1] ‚ÄúThe Needleman-Wunsch algorithm for sequence alignment,‚Äù [Online]. Available:¬†[https://www.cs.sjsu.edu/~aid/cs152/NeedlemanWunsch.pdf.](https://www.cs.sjsu.edu/~aid/cs152/NeedlemanWunsch.pdf.)
